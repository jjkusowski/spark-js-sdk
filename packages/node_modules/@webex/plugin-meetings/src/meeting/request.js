import {StatelessSparkPlugin} from '@ciscospark/spark-core';

import {PARTICIPANT, LOCI, CALL, POST, PUT, LEAVE, MEDIA} from '../constants';

/**
 * @class MeetingRequest
 */
export default class MeetingRequest extends StatelessSparkPlugin {
  /**
   * Make a network request to join a meeting
   * @param {Object} options
   * @param {String} options.sipUri
   * @param {String} options.deviceUrl
   * @param {String} options.locusUrl
   * @param {String} options.resourceId,
   * @param {String} options.correlationId
   * @returns {Promise}
   */
  joinMeeting(options) {
    const {
      sipUri, deviceUrl, locusUrl, resourceId, correlationId, ensureConversation
    } = options;

    let url = '';

    const body = {
      deviceUrl,
      usingResource: resourceId || null,
      correlationId,
      respOnlySdp: true,
      supportsNativeLobby: 1,
      allowMultiDevice: true,
      ensureConversation: ensureConversation || false
    };

    if (locusUrl) {
      url = `${locusUrl}/${PARTICIPANT}`;
    }
    else if (sipUri) {
      // eslint-lin-disable-next-line no-warning-comments
      // TODO switch to use the locus object and look into federation?
      url = `${this.spark.internal.device.services.locusServiceUrl}/${LOCI}/${CALL}`;
      body.invitee = {
        address: sipUri
      };
    }

    return this.spark.request({
      method: POST,
      uri: url,
      qs: {alternateRedirect: true}, // for handling locus URL redirections
      body
    });
  }

  /**
   * Make a network request to leave a meeting
   * @param {Object} options
   * @param {String} options.deviceUrl
   * @param {String} options.resourceId,
   * @param {String} options.correlationId
   * @returns {Promise}
   */
  leaveMeeting(options) {
    const url = `${options.locusUrl}/${PARTICIPANT}/${options.selfId}/${LEAVE}`;
    const body = {
      deviceUrl: options.deviceUrl,
      usingResource: options.resourceId,
      correlationId: options.correlationId
    };
    return this.request({
      method: PUT,
      uri: url,
      body
    });
  }

  /**
   * Toggle remote audio and/or video
   * @param {Object} options options for toggling
   * @param {String} options.selfId Locus self id??
   * @param {String} options.locusUrl Locus url
   * @param {String} options.deviceUrl Url of a device
   * @param {String} options.resourceId Populated if you are paired to a device
   * @param {String} options.localMedias local sdps
   * @returns {Promise}
   */
  remoteAudioVideoToggle(options) {
    const url = `${options.locusUrl}/${PARTICIPANT}/${options.selfId}/${MEDIA}`;
    const body = {
      deviceUrl: options.deviceUrl,
      usingResource: options.resourceId || null,
      correlationId: options.correlationId,
      respOnlySdp: true,
      localMedias: options.localMedias
    };
    return this.request({
      method: PUT,
      uri: url,
      body
    });
  }

  changeMeetingFloor(meeting, isStart) {
    const disposition = isStart ? 'GRANTED' : 'RELEASED';

    let floorReq = {disposition};
    /* istanbul ignore else */
    if (disposition === 'GRANTED') {
      floorReq = {
        beneficiary: {
          url: meeting.person.url,
          devices: [{url: meeting.deviceUrl}]
        },
        disposition,
        requester: {
          url: meeting.person.url
        }
      };
    }

    return this.request({
      uri: meeting.locusUrl,
      method: 'PUT',
      body: {
        floor: floorReq,
        resourceUrl: meeting.resourceUrl
      }
    });
  }
}
